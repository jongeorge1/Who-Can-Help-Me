//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace MSpecTests.WhoCanHelpMe.Tasks
{
    #region Using Directives

    using System.Collections.Generic;
    using System.Linq;

    using global::WhoCanHelpMe.Domain;
    using global::WhoCanHelpMe.Domain.Contracts.Repositories;
    using global::WhoCanHelpMe.Domain.Contracts.Tasks;
    using global::WhoCanHelpMe.Domain.Specifications;
    using global::WhoCanHelpMe.Tasks;

    using Machine.Specifications;
    using Machine.Specifications.AutoMocking.Rhino;
    using Machine.Specifications.Runner.Impl;

    using Rhino.Mocks;

    #endregion

    public abstract class specification_for_tag_tasks : Specification<ITagTasks, TagTasks>
    {
        protected static ITagRepository the_tag_repository;

        Establish context = () =>
        {
            the_tag_repository = DependencyOf<ITagRepository>();
        };
    }

    [Subject(typeof(TagTasks))]
    public class when_the_tag_tasks_are_asked_to_get_tags_matching_starting_characters_but_no_characters_are_supplied : specification_for_tag_tasks
    {
        static string the_starting_characters;
        static IList<Tag> result;

        Establish context = () => the_starting_characters = string.Empty;

        Because of = () => result = subject.GetWhereNameStartsWith(the_starting_characters);

        It should_not_ask_the_repository_for_matching_tags = () => the_tag_repository.AssertWasNotCalled(r => r.FindAll(Arg<TagByFirstCharactersOfNameSpecification>.Is.Anything));

        It should_return_an_empty_list = () => result.ShouldBeEmpty();
    }

    [Subject(typeof(TagTasks))]
    public class when_the_tag_tasks_are_asked_to_get_tags_matching_starting_characters_and_there_are_matching_tags : specification_for_tag_tasks
    {
        static string the_starting_characters;
        static IQueryable<Tag> the_matching_tags;
        static IList<Tag> result;

        Establish context = () =>
        {
            the_starting_characters = "ab";

            the_matching_tags = new List<Tag> {
                                                      new Tag { Name = "X" },
                                                      new Tag { Name = "A" },
                                                      new Tag { Name = "M" },
                                                  }.AsQueryable();

            the_tag_repository.Stub(r => r.FindAll(Arg<TagByFirstCharactersOfNameSpecification>.Is.Anything)).Return(the_matching_tags);
        };

        Because of = () => result = subject.GetWhereNameStartsWith(the_starting_characters);

        It should_ask_the_tag_repository_for_the_matching_tags = () => the_tag_repository.AssertWasCalled(r => r.FindAll(Arg<TagByFirstCharactersOfNameSpecification>.Matches(s => s.StartingCharacters == the_starting_characters)));

        It should_return_the_list_of_matching_tags = () => the_matching_tags.ForEach(m => result.ShouldContain(m)); // ShouldContainOnly doesn't work - the assertion is badly named, as it is broken by different orderings of elements

        It should_sort_the_matching_tags_alphabetically = () =>
        {
            for (int index = 1; index < result.Count; index++)
            {
                result[index - 1].Name.ShouldBeLessThan(result[index].Name);
            }
        };
    }

    [Subject(typeof(TagTasks))]
    public class when_the_tag_tasks_are_asked_to_get_tags_matching_starting_characters_and_there_are_no_matching_tags : specification_for_tag_tasks
    {
        static string the_starting_characters;
        static IQueryable<Tag> the_matching_tags;
        static IList<Tag> result;

        Establish context = () =>
        {
            the_starting_characters = "ab";

            the_matching_tags = new List<Tag>().AsQueryable();

            the_tag_repository.Stub(r => r.FindAll(Arg<TagByFirstCharactersOfNameSpecification>.Is.Anything)).Return(the_matching_tags);
        };

        Because of = () => result = subject.GetWhereNameStartsWith(the_starting_characters);

        It should_ask_the_tag_repository_for_the_matching_tags = () => the_tag_repository.AssertWasCalled(r => r.FindAll(Arg<TagByFirstCharactersOfNameSpecification>.Matches(s => s.StartingCharacters == the_starting_characters)));

        It should_return_an_empty_list = () => result.ShouldBeEmpty();
    }

    [Subject(typeof(TagTasks))]
    public class when_the_tag_tasks_are_asked_for_the_most_popular_tags : specification_for_tag_tasks
    {
        static int the_tag_count;
        static IQueryable<Tag> the_matching_tags;
        static IList<Tag> result;

        static Tag tag_1;
        static Tag tag_2;
        static Tag tag_3;

        Establish context = () =>
        {
            the_tag_count = 2;
 
            tag_1 = new Tag { Name = "X", Views = 1 };
            tag_2 = new Tag { Name = "A", Views = 50 };
            tag_3 = new Tag { Name = "M", Views = 100 };

            the_matching_tags = new List<Tag> {
                                                  tag_1,
                                                  tag_2,
                                                  tag_3,
                                              }.AsQueryable();

            the_tag_repository.Stub(r => r.FindAll()).Return(the_matching_tags);
        };

        Because of = () => result = subject.GetMostPopularTags(the_tag_count);

        It should_ask_the_tag_repository_for_the_popular_tags = () => the_tag_repository.AssertWasCalled(r => r.FindAll());

        It should_return_two_tags = () => result.Count.ShouldEqual(2);

        It should_sort_the_tag_list_correctly = () =>
            {
                result[0].ShouldEqual(tag_3);
                result[1].ShouldEqual(tag_2);
            };
    }

    [Subject(typeof(TagTasks))]
    public class when_the_tag_tasks_are_asked_to_get_a_tag_by_name : specification_for_tag_tasks
    {
        static Tag result;
        static Tag the_tag;
        static string the_tag_name;

        Establish context = () =>
            {
                the_tag_name = "tag name";

                the_tag = new Tag();

                the_tag_repository.Stub(r => r.FindAll(Arg<TagByNameSpecification>.Is.Anything)).Return(new List<Tag> { the_tag }.AsQueryable());
            };

        Because of = () => result = subject.GetByName(the_tag_name);

        It should_ask_the_tag_repository_for_the_matching_tag = () => the_tag_repository.AssertWasCalled(r => r.FindAll(Arg<TagByNameSpecification>.Matches(s => s.Name == the_tag_name)));

        It should_return_the_matching_tag = () => result.ShouldBeTheSameAs(the_tag);

    }

    [Subject(typeof(TagTasks))]
    public class when_the_tag_tasks_are_asked_to_get_a_tag_by_name_and_there_is_no_matching_tag : specification_for_tag_tasks
    {
        static Tag result;
        static string the_tag_name;

        Establish context = () =>
        {
            the_tag_name = "tag name";

            the_tag_repository.Stub(r => r.FindAll(Arg<TagByNameSpecification>.Is.Anything)).Return(new List<Tag>().AsQueryable());
        };

        Because of = () => result = subject.GetByName(the_tag_name);

        It should_ask_the_tag_repository_for_the_matching_tag = () => the_tag_repository.AssertWasCalled(r => r.FindAll(Arg<TagByNameSpecification>.Matches(s => s.Name == the_tag_name)));

        It should_return_null = () => result.ShouldBeNull();
    }
}
